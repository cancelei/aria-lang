# Aria Standard Library - Environment Module
# Environment variables and program arguments

# Gets an environment variable
fn get_env(name: String) -> Option<String>
  # TODO: Native implementation
  None
end

# Gets an environment variable with a default value
fn get_env_or(name: String, default: String) -> String
  match get_env(name)
    Some(value) -> value
    None -> default
  end
end

# Sets an environment variable
fn set_env(name: String, value: String)
  # TODO: Native implementation
end

# Removes an environment variable
fn remove_env(name: String)
  # TODO: Native implementation
end

# Gets all environment variables
fn env_vars() -> Map<String, String>
  # TODO: Native implementation
  {}
end

# Checks if an environment variable exists
fn has_env(name: String) -> Bool
  get_env(name).is_some()
end

# Gets command line arguments
fn args() -> [String]
  # TODO: Native implementation
  []
end

# Gets the number of command line arguments
fn args_count() -> Int
  args().len()
end

# Gets a specific argument by index
fn arg(index: Int) -> Option<String>
  let arguments = args()
  if index >= 0 && index < arguments.len()
    Some(arguments[index])
  else
    None
  end
end

# Gets the program name (first argument)
fn program_name() -> Option<String>
  arg(0)
end

# Gets the current working directory
fn current_dir() -> Result<String, String>
  # TODO: Native implementation
  Err("Not implemented")
end

# Changes the current working directory
fn set_current_dir(path: String) -> Result<(), String>
  # TODO: Native implementation
  Err("Not implemented")
end

# Gets the user's home directory
fn home_dir() -> Option<String>
  # Try common environment variables
  get_env("HOME").or(get_env("USERPROFILE"))
end

# Gets the temporary directory
fn temp_dir() -> String
  get_env_or("TMPDIR", get_env_or("TMP", get_env_or("TEMP", "/tmp")))
end

# Gets the path separator for the current OS
fn path_separator() -> String
  # TODO: Detect OS properly
  "/"
end

# Gets the line separator for the current OS
fn line_separator() -> String
  # TODO: Detect OS properly
  "\n"
end

# Platform information
struct Platform
  os: String
  arch: String
  family: String
end

impl Platform
  fn current() -> Platform
    # TODO: Native implementation to detect actual platform
    Platform {
      os: "unknown",
      arch: "unknown",
      family: "unknown"
    }
  end

  fn is_unix(self) -> Bool
    self.family == "unix"
  end

  fn is_windows(self) -> Bool
    self.family == "windows"
  end

  fn is_macos(self) -> Bool
    self.os == "macos"
  end

  fn is_linux(self) -> Bool
    self.os == "linux"
  end
end

# Gets current platform
fn platform() -> Platform
  Platform::current()
end

# Exits the program with a status code
fn exit(code: Int)
  # TODO: Native implementation
  panic("Program exited with code #{code}")
end

# Abort the program immediately
fn abort()
  # TODO: Native implementation
  panic("Program aborted")
end
