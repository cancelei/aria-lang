# Aria Standard Library - Option Type
# Optional values

# Option type representing a value that may or may not exist
enum Option<T>
  Some(T)
  None
end

impl Option<T>
  # Returns true if the option is Some
  fn is_some(self) -> Bool
    match self
      Some(_) -> true
      None -> false
    end
  end

  # Returns true if the option is None
  fn is_none(self) -> Bool
    match self
      Some(_) -> false
      None -> true
    end
  end

  # Unwraps the option, panicking if None
  fn unwrap(self) -> T
    match self
      Some(value) -> value
      None -> panic("called `Option::unwrap()` on a `None` value")
    end
  end

  # Unwraps the option or returns a default value
  fn unwrap_or(self, default: T) -> T
    match self
      Some(value) -> value
      None -> default
    end
  end

  # Unwraps the option or computes a default value
  fn unwrap_or_else(self, f: Fn() -> T) -> T
    match self
      Some(value) -> value
      None -> f()
    end
  end

  # Returns the option if it contains a value, otherwise returns other
  fn or(self, other: Option<T>) -> Option<T>
    match self
      Some(_) -> self
      None -> other
    end
  end

  # Returns None if the option is None, otherwise calls f with the wrapped value
  fn and_then(self, f: Fn(T) -> Option<U>) -> Option<U>
    match self
      Some(value) -> f(value)
      None -> None
    end
  end

  # Maps an Option<T> to Option<U> by applying a function
  fn map(self, f: Fn(T) -> U) -> Option<U>
    match self
      Some(value) -> Some(f(value))
      None -> None
    end
  end

  # Maps an Option<T> to Option<U> or returns a default
  fn map_or(self, default: U, f: Fn(T) -> U) -> U
    match self
      Some(value) -> f(value)
      None -> default
    end
  end

  # Filters the option based on a predicate
  fn filter(self, predicate: Fn(T) -> Bool) -> Option<T>
    match self
      Some(value) ->
        if predicate(value)
          Some(value)
        else
          None
        end
      None -> None
    end
  end

  # Converts from Option<Option<T>> to Option<T>
  fn flatten(self) -> Option<T>
    match self
      Some(Some(value)) -> Some(value)
      Some(None) -> None
      None -> None
    end
  end

  # Takes the value out of the option, leaving None in its place
  fn take(mut self) -> Option<T>
    let value = self
    self = None
    value
  end
end

# Helper function to create Some
fn Some(value: T) -> Option<T>
  Option::Some(value)
end

# Helper function to create None
fn None() -> Option<T>
  Option::None
end
