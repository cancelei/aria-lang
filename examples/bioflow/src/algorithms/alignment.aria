# BioFlow - Sequence Alignment Algorithms
# Smith-Waterman and Needleman-Wunsch alignment with contracts

import core::sequence::{Sequence, SequenceType}
import core::alignment::{Alignment, AlignmentType, AlignDirection}

# Scoring matrix for nucleotide alignment
struct ScoringMatrix
  match_score: Int
  mismatch_penalty: Int
  gap_open_penalty: Int
  gap_extend_penalty: Int

  # Invariant: match score should be positive
  invariant self.match_score > 0 : "Match score must be positive"

  # Invariant: penalties should be non-positive (or zero for no penalty)
  invariant self.mismatch_penalty <= 0 : "Mismatch penalty should be <= 0"
  invariant self.gap_open_penalty <= 0 : "Gap open penalty should be <= 0"
  invariant self.gap_extend_penalty <= 0 : "Gap extend penalty should be <= 0"
end

impl ScoringMatrix
  # Creates default DNA scoring matrix
  fn default_dna() -> ScoringMatrix
    ScoringMatrix {
      match_score: 2,
      mismatch_penalty: -1,
      gap_open_penalty: -2,
      gap_extend_penalty: -1
    }
  end

  # Creates BLAST-like scoring matrix
  fn blast_like() -> ScoringMatrix
    ScoringMatrix {
      match_score: 1,
      mismatch_penalty: -3,
      gap_open_penalty: -5,
      gap_extend_penalty: -2
    }
  end

  # Creates a simple scoring matrix (no affine gaps)
  fn simple(match_val: Int, mismatch: Int, gap: Int) -> ScoringMatrix
    requires match_val > 0
    requires mismatch <= 0
    requires gap <= 0

    ScoringMatrix {
      match_score: match_val,
      mismatch_penalty: mismatch,
      gap_open_penalty: gap,
      gap_extend_penalty: gap
    }
  end

  # Returns score for comparing two bases
  fn score(self, base1: Char, base2: Char) -> Int
    if base1 == base2
      self.match_score
    else
      self.mismatch_penalty
    end
  end

  # Returns gap penalty (linear model for simplicity)
  fn gap_penalty(self) -> Int
    self.gap_open_penalty
  end
end

# Alignment configuration
struct AlignmentConfig
  scoring: ScoringMatrix
  alignment_type: AlignmentType
  max_alignments: Int      # Maximum number of alignments to return
  min_score: Int           # Minimum score threshold

  invariant self.max_alignments > 0
end

impl AlignmentConfig
  fn default() -> AlignmentConfig
    AlignmentConfig {
      scoring: ScoringMatrix::default_dna(),
      alignment_type: AlignmentType::Local,
      max_alignments: 1,
      min_score: 0
    }
  end

  fn global() -> AlignmentConfig
    AlignmentConfig {
      scoring: ScoringMatrix::default_dna(),
      alignment_type: AlignmentType::Global,
      max_alignments: 1,
      min_score: 0
    }
  end

  fn with_scoring(mut self, scoring: ScoringMatrix) -> AlignmentConfig
    self.scoring = scoring
    self
  end

  fn with_min_score(mut self, min_score: Int) -> AlignmentConfig
    self.min_score = min_score
    self
  end
end

# Smith-Waterman local alignment algorithm
#
# Contracts:
# - requires: both sequences are valid and non-empty
# - ensures: alignment score >= 0 for local alignment
# - ensures: aligned sequences have equal length
fn smith_waterman(seq1: Sequence, seq2: Sequence, scoring: ScoringMatrix) -> Alignment
  requires seq1.is_valid() and seq2.is_valid()
  requires seq1.len() > 0 and seq2.len() > 0
  ensures result.score >= 0
  ensures result.aligned_seq1.len() == result.aligned_seq2.len()

  let m = seq1.len()
  let n = seq2.len()

  # Initialize scoring matrix (m+1 x n+1)
  let mut H = []
  let mut i = 0
  loop
    if i > m
      break
    end
    let mut row = []
    let mut j = 0
    loop
      if j > n
        break
      end
      row.push(0)
      j = j + 1
    end
    H.push(row)
    i = i + 1
  end

  # Initialize traceback matrix
  let mut traceback = []
  let mut i2 = 0
  loop
    if i2 > m
      break
    end
    let mut row = []
    let mut j = 0
    loop
      if j > n
        break
      end
      row.push(AlignDirection::Stop)
      j = j + 1
    end
    traceback.push(row)
    i2 = i2 + 1
  end

  # Track maximum score and position
  let mut max_score = 0
  let mut max_i = 0
  let mut max_j = 0

  # Fill matrices
  let mut i3 = 1
  loop
    if i3 > m
      break
    end

    let mut j = 1
    loop
      if j > n
        break
      end

      let base1 = seq1.bases.char_at(i3 - 1)
      let base2 = seq2.bases.char_at(j - 1)
      let match_score = scoring.score(base1, base2)

      # Calculate scores for each direction
      let diag = H[i3 - 1][j - 1] + match_score
      let up = H[i3 - 1][j] + scoring.gap_penalty()
      let left = H[i3][j - 1] + scoring.gap_penalty()

      # Find maximum (including 0 for local alignment)
      let mut best = 0
      let mut dir = AlignDirection::Stop

      if diag > best
        best = diag
        dir = AlignDirection::Diagonal
      end

      if up > best
        best = up
        dir = AlignDirection::Up
      end

      if left > best
        best = left
        dir = AlignDirection::Left
      end

      H[i3][j] = best
      traceback[i3][j] = dir

      # Update maximum
      if best > max_score
        max_score = best
        max_i = i3
        max_j = j
      end

      j = j + 1
    end

    i3 = i3 + 1
  end

  # Traceback to build alignment
  let (aligned1, aligned2, start1, start2) = traceback_local(
    seq1.bases, seq2.bases, traceback, max_i, max_j
  )

  Alignment::with_positions(
    aligned1, aligned2, max_score,
    start1, max_i, start2, max_j,
    AlignmentType::Local
  ).unwrap()
end

# Performs traceback for local alignment
fn traceback_local(
  seq1: String,
  seq2: String,
  traceback: [[AlignDirection]],
  start_i: Int,
  start_j: Int
) -> (String, String, Int, Int)
  requires start_i > 0 and start_j > 0

  let mut aligned1 = ""
  let mut aligned2 = ""
  let mut i = start_i
  let mut j = start_j

  loop
    match traceback[i][j]
      AlignDirection::Stop => break
      AlignDirection::Diagonal => {
        aligned1 = seq1.char_at(i - 1).to_string() + aligned1
        aligned2 = seq2.char_at(j - 1).to_string() + aligned2
        i = i - 1
        j = j - 1
      }
      AlignDirection::Up => {
        aligned1 = seq1.char_at(i - 1).to_string() + aligned1
        aligned2 = "-" + aligned2
        i = i - 1
      }
      AlignDirection::Left => {
        aligned1 = "-" + aligned1
        aligned2 = seq2.char_at(j - 1).to_string() + aligned2
        j = j - 1
      }
    end

    if i == 0 or j == 0
      break
    end
  end

  (aligned1, aligned2, i, j)
end

# Needleman-Wunsch global alignment algorithm
#
# Contracts:
# - requires: both sequences are valid and non-empty
# - ensures: aligned sequences cover entire input sequences
fn needleman_wunsch(seq1: Sequence, seq2: Sequence, scoring: ScoringMatrix) -> Alignment
  requires seq1.is_valid() and seq2.is_valid()
  requires seq1.len() > 0 and seq2.len() > 0
  ensures result.aligned_seq1.len() == result.aligned_seq2.len()

  let m = seq1.len()
  let n = seq2.len()

  # Initialize scoring matrix with gap penalties for first row/column
  let mut H = []
  let mut i = 0
  loop
    if i > m
      break
    end
    let mut row = []
    let mut j = 0
    loop
      if j > n
        break
      end
      if i == 0
        row.push(j * scoring.gap_penalty())
      else if j == 0
        row.push(i * scoring.gap_penalty())
      else
        row.push(0)
      end
      j = j + 1
    end
    H.push(row)
    i = i + 1
  end

  # Initialize traceback matrix
  let mut traceback = []
  let mut i2 = 0
  loop
    if i2 > m
      break
    end
    let mut row = []
    let mut j = 0
    loop
      if j > n
        break
      end
      if i2 == 0 and j > 0
        row.push(AlignDirection::Left)
      else if j == 0 and i2 > 0
        row.push(AlignDirection::Up)
      else
        row.push(AlignDirection::Stop)
      end
      j = j + 1
    end
    traceback.push(row)
    i2 = i2 + 1
  end

  # Fill matrices
  let mut i3 = 1
  loop
    if i3 > m
      break
    end

    let mut j = 1
    loop
      if j > n
        break
      end

      let base1 = seq1.bases.char_at(i3 - 1)
      let base2 = seq2.bases.char_at(j - 1)
      let match_score = scoring.score(base1, base2)

      let diag = H[i3 - 1][j - 1] + match_score
      let up = H[i3 - 1][j] + scoring.gap_penalty()
      let left = H[i3][j - 1] + scoring.gap_penalty()

      # Find maximum (no 0 threshold for global alignment)
      let mut best = diag
      let mut dir = AlignDirection::Diagonal

      if up > best
        best = up
        dir = AlignDirection::Up
      end

      if left > best
        best = left
        dir = AlignDirection::Left
      end

      H[i3][j] = best
      traceback[i3][j] = dir

      j = j + 1
    end

    i3 = i3 + 1
  end

  # Traceback from bottom-right corner
  let (aligned1, aligned2) = traceback_global(seq1.bases, seq2.bases, traceback, m, n)

  Alignment::new(aligned1, aligned2, H[m][n], AlignmentType::Global).unwrap()
end

# Performs traceback for global alignment
fn traceback_global(
  seq1: String,
  seq2: String,
  traceback: [[AlignDirection]],
  m: Int,
  n: Int
) -> (String, String)
  requires m >= 0 and n >= 0

  let mut aligned1 = ""
  let mut aligned2 = ""
  let mut i = m
  let mut j = n

  loop
    if i == 0 and j == 0
      break
    end

    if i == 0
      aligned1 = "-" + aligned1
      aligned2 = seq2.char_at(j - 1).to_string() + aligned2
      j = j - 1
    else if j == 0
      aligned1 = seq1.char_at(i - 1).to_string() + aligned1
      aligned2 = "-" + aligned2
      i = i - 1
    else
      match traceback[i][j]
        AlignDirection::Diagonal => {
          aligned1 = seq1.char_at(i - 1).to_string() + aligned1
          aligned2 = seq2.char_at(j - 1).to_string() + aligned2
          i = i - 1
          j = j - 1
        }
        AlignDirection::Up => {
          aligned1 = seq1.char_at(i - 1).to_string() + aligned1
          aligned2 = "-" + aligned2
          i = i - 1
        }
        AlignDirection::Left => {
          aligned1 = "-" + aligned1
          aligned2 = seq2.char_at(j - 1).to_string() + aligned2
          j = j - 1
        }
        _ => break
      end
    end
  end

  (aligned1, aligned2)
end

# Simple alignment function using default settings
fn simple_align(seq1: Sequence, seq2: Sequence) -> Alignment
  requires seq1.is_valid() and seq2.is_valid()
  requires seq1.len() > 0 and seq2.len() > 0

  smith_waterman(seq1, seq2, ScoringMatrix::default_dna())
end

# Aligns a sequence against multiple targets
fn align_against_multiple(
  query: Sequence,
  targets: [Sequence],
  scoring: ScoringMatrix
) -> [(Int, Alignment)]
  requires query.is_valid()
  requires targets.len() > 0
  ensures result.len() == targets.len()

  let mut results = []

  let mut i = 0
  loop
    if i >= targets.len()
      break
    end

    let alignment = smith_waterman(query, targets[i], scoring)
    results.push((i, alignment))

    i = i + 1
  end

  results
end

# Finds best alignment among multiple targets
fn find_best_alignment(
  query: Sequence,
  targets: [Sequence],
  scoring: ScoringMatrix
) -> Option<(Int, Alignment)>
  requires query.is_valid()
  requires targets.len() > 0

  let alignments = align_against_multiple(query, targets, scoring)

  let mut best_idx = 0
  let mut best_score = alignments[0].1.score

  let mut i = 1
  loop
    if i >= alignments.len()
      break
    end

    if alignments[i].1.score > best_score
      best_score = alignments[i].1.score
      best_idx = i
    end

    i = i + 1
  end

  Some(alignments[best_idx])
end

# Calculates alignment score without full traceback (faster)
fn alignment_score_only(seq1: Sequence, seq2: Sequence, scoring: ScoringMatrix) -> Int
  requires seq1.is_valid() and seq2.is_valid()
  requires seq1.len() > 0 and seq2.len() > 0

  let m = seq1.len()
  let n = seq2.len()

  # Use two rows instead of full matrix for memory efficiency
  let mut prev_row = []
  let mut curr_row = []

  # Initialize
  let mut j = 0
  loop
    if j > n
      break
    end
    prev_row.push(0)
    curr_row.push(0)
    j = j + 1
  end

  let mut max_score = 0

  let mut i = 1
  loop
    if i > m
      break
    end

    # Reset current row
    let mut j2 = 0
    loop
      if j2 > n
        break
      end
      curr_row[j2] = 0
      j2 = j2 + 1
    end

    let mut j3 = 1
    loop
      if j3 > n
        break
      end

      let base1 = seq1.bases.char_at(i - 1)
      let base2 = seq2.bases.char_at(j3 - 1)
      let match_score = scoring.score(base1, base2)

      let diag = prev_row[j3 - 1] + match_score
      let up = prev_row[j3] + scoring.gap_penalty()
      let left = curr_row[j3 - 1] + scoring.gap_penalty()

      let mut best = 0
      if diag > best then best = diag end
      if up > best then best = up end
      if left > best then best = left end

      curr_row[j3] = best

      if best > max_score
        max_score = best
      end

      j3 = j3 + 1
    end

    # Swap rows
    let temp = prev_row
    prev_row = curr_row
    curr_row = temp

    i = i + 1
  end

  max_score
end

# Calculates percent identity between two aligned sequences
fn percent_identity(aligned1: String, aligned2: String) -> Float
  requires aligned1.len() == aligned2.len()
  requires aligned1.len() > 0
  ensures result >= 0.0 and result <= 100.0

  let mut matches = 0
  let mut i = 0

  loop
    if i >= aligned1.len()
      break
    end

    let c1 = aligned1.char_at(i)
    let c2 = aligned2.char_at(i)

    if c1 == c2 and c1 != '-'
      matches = matches + 1
    end

    i = i + 1
  end

  (matches.to_float() / aligned1.len().to_float()) * 100.0
end

# Calculates alignment coverage
fn alignment_coverage(alignment: Alignment, seq_length: Int) -> Float
  requires seq_length > 0
  ensures result >= 0.0 and result <= 1.0

  let aligned_bases = alignment.alignment_length() - alignment.gaps_seq1()
  aligned_bases.to_float() / seq_length.to_float()
end
