# Aria Standard Library Demo
# Demonstrates usage of the stdlib for BioFlow-like programs

import std::collections::HashMap
import std::io::*

# Example 1: String operations
fn process_dna_sequence(seq: String) -> String
  # Clean and normalize a DNA sequence
  seq.trim()
     .to_uppercase()
     .replace(" ", "")
     .replace("-", "")
end

# Example 2: Count nucleotides using HashMap
fn count_nucleotides(sequence: String) -> HashMap<Char, Int>
  let mut counts = HashMap::new()

  # Initialize counts
  counts.insert('A', 0)
  counts.insert('C', 0)
  counts.insert('G', 0)
  counts.insert('T', 0)

  # Count each nucleotide
  let mut i = 0
  while i < sequence.len()
    let base = sequence.char_at(i)
    match counts.get(base)
      Some(count) -> counts.insert(base, count + 1)
      None -> {}  # Skip unknown characters
    end
    i = i + 1
  end

  counts
end

# Example 3: K-mer counting
fn count_kmers(sequence: String, k: Int) -> HashMap<String, Int>
  let mut kmer_counts = HashMap::new()

  let mut i = 0
  while i <= sequence.len() - k
    let kmer = sequence.slice(i, i + k)

    match kmer_counts.get(kmer)
      Some(count) -> kmer_counts.insert(kmer, count + 1)
      None -> kmer_counts.insert(kmer, 1)
    end

    i = i + 1
  end

  kmer_counts
end

# Example 4: Calculate GC content
fn gc_content(sequence: String) -> Float
  let mut gc_count = 0
  let mut total = 0

  let mut i = 0
  while i < sequence.len()
    let base = sequence.char_at(i)
    if base == 'G' || base == 'C'
      gc_count = gc_count + 1
    end
    total = total + 1
    i = i + 1
  end

  if total == 0
    return 0.0
  end

  (gc_count as Float) / (total as Float) * 100.0
end

# Example 5: Find reverse complement
fn reverse_complement(sequence: String) -> String
  let complement_map = hashmap_from([
    ('A', 'T'),
    ('T', 'A'),
    ('C', 'G'),
    ('G', 'C')
  ])

  let mut result = ""
  let mut i = sequence.len() - 1

  while i >= 0
    let base = sequence.char_at(i)
    match complement_map.get(base)
      Some(comp) -> result = result.concat(comp.to_string())
      None -> result = result.concat(base.to_string())
    end
    i = i - 1
  end

  result
end

# Example 6: Validate DNA sequence
fn is_valid_dna(sequence: String) -> Result<(), String>
  let valid_bases = hashset_from(['A', 'C', 'G', 'T'])

  let mut i = 0
  while i < sequence.len()
    let base = sequence.char_at(i)
    if !valid_bases.contains(base)
      return Err("Invalid base: #{base} at position #{i}")
    end
    i = i + 1
  end

  Ok(())
end

# Example 7: Process FASTA-like file
fn process_sequences(path: String) -> Result<[String], IoError>
  println("Reading sequences from: #{path}")

  match read_file(path)
    Ok(content) ->
      let lines = content.split("\n")
      let sequences = lines.filter(fn(line) ->
        !line.is_empty() && !line.starts_with(">")
      )

      println("Found #{sequences.len()} sequences")
      Ok(sequences)

    Err(e) ->
      eprintln("Failed to read file: #{e.message()}")
      Err(e)
  end
end

# Main function demonstrating all features
fn main()
  println("=== Aria Standard Library Demo ===\n")

  # Demo 1: String processing
  println("1. String Processing:")
  let raw_seq = "  atcg-atcg  "
  let clean_seq = process_dna_sequence(raw_seq)
  println("  Raw:   '#{raw_seq}'")
  println("  Clean: '#{clean_seq}'\n")

  # Demo 2: Nucleotide counting
  println("2. Nucleotide Counting:")
  let test_seq = "ATCGATCGATCG"
  let counts = count_nucleotides(test_seq)
  println("  Sequence: #{test_seq}")
  counts.for_each(fn(base, count) ->
    println("  #{base}: #{count}")
  )
  println()

  # Demo 3: K-mer counting
  println("3. K-mer Counting (k=3):")
  let kmers = count_kmers(test_seq, 3)
  println("  Found #{kmers.len()} unique 3-mers")
  kmers.for_each(fn(kmer, count) ->
    println("  #{kmer}: #{count}")
  )
  println()

  # Demo 4: GC content
  println("4. GC Content:")
  let gc = gc_content(test_seq)
  println("  Sequence: #{test_seq}")
  println("  GC%: #{gc}%\n")

  # Demo 5: Reverse complement
  println("5. Reverse Complement:")
  let seq = "ATCG"
  let rev_comp = reverse_complement(seq)
  println("  Original: #{seq}")
  println("  RevComp:  #{rev_comp}\n")

  # Demo 6: Sequence validation
  println("6. Sequence Validation:")
  match is_valid_dna("ATCG")
    Ok(_) -> println("  'ATCG' is valid")
    Err(e) -> println("  Error: #{e}")
  end

  match is_valid_dna("ATXG")
    Ok(_) -> println("  'ATXG' is valid")
    Err(e) -> println("  Error: #{e}")
  end

  println("\n=== Demo Complete ===")
end
